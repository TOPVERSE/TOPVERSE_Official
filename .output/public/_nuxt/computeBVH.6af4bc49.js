import{L as N,a as gt,G as ue,b as pe,d as de,M as he,P as ye,T as Ct,V as _,S as me,e as oe,B as $,f as bt,F as Ot,O as xe,g as we,h as at,i as Ae,D as ge}from"./model.vue.8f6f7b03.js";var be=Object.defineProperty,Pe=Object.defineProperties,Te=Object.getOwnPropertyDescriptors,qt=Object.getOwnPropertySymbols,Be=Object.prototype.hasOwnProperty,Me=Object.prototype.propertyIsEnumerable,Nt=(n,t,e)=>t in n?be(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,Bt=(n,t)=>{for(var e in t||(t={}))Be.call(t,e)&&Nt(n,e,t[e]);if(qt)for(var e of qt(t))Me.call(t,e)&&Nt(n,e,t[e]);return n},Se=(n,t)=>Pe(n,Te(t));const re=0,ve=1,Ie=2,Ht=2,Mt=1.25,jt=1,wt=6*4+4+4,Vt=65535,_e=Math.pow(2,-24);class ft{constructor(){}}function U(n,t,e){return e.min.x=t[n],e.min.y=t[n+1],e.min.z=t[n+2],e.max.x=t[n+3],e.max.y=t[n+4],e.max.z=t[n+5],e}function kt(n){let t=-1,e=-1/0;for(let i=0;i<3;i++){const s=n[i+3]-n[i];s>e&&(e=s,t=i)}return t}function Xt(n,t){t.set(n)}function Wt(n,t,e){let i,s;for(let r=0;r<3;r++){const o=r+3;i=n[r],s=t[r],e[r]=i<s?i:s,i=n[o],s=t[o],e[o]=i>s?i:s}}function ut(n,t,e){for(let i=0;i<3;i++){const s=t[n+2*i],r=t[n+2*i+1],o=s-r,l=s+r;o<e[i]&&(e[i]=o),l>e[i+3]&&(e[i+3]=l)}}function et(n){const t=n[3]-n[0],e=n[4]-n[1],i=n[5]-n[2];return 2*(t*e+e*i+i*t)}function Ce(n,t){if(!n.index){const e=n.attributes.position.count,i=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let s;e>65535?s=new Uint32Array(new i(4*e)):s=new Uint16Array(new i(2*e)),n.setIndex(new bt(s,1));for(let r=0;r<e;r++)s[r]=r}}function Ve(n){if(!n.groups||!n.groups.length)return[{offset:0,count:n.index.count/3}];const t=[],e=new Set;for(const s of n.groups)e.add(s.start),e.add(s.start+s.count);const i=Array.from(e.values()).sort((s,r)=>s-r);for(let s=0;s<i.length-1;s++){const r=i[s],o=i[s+1];t.push({offset:r/3,count:(o-r)/3})}return t}function St(n,t,e,i,s=null){let r=1/0,o=1/0,l=1/0,c=-1/0,f=-1/0,a=-1/0,u=1/0,p=1/0,d=1/0,g=-1/0,w=-1/0,A=-1/0;const y=s!==null;for(let m=t*6,h=(t+e)*6;m<h;m+=6){const x=n[m+0],b=n[m+1],P=x-b,M=x+b;P<r&&(r=P),M>c&&(c=M),y&&x<u&&(u=x),y&&x>g&&(g=x);const B=n[m+2],T=n[m+3],S=B-T,v=B+T;S<o&&(o=S),v>f&&(f=v),y&&B<p&&(p=B),y&&B>w&&(w=B);const I=n[m+4],C=n[m+5],F=I-C,V=I+C;F<l&&(l=F),V>a&&(a=V),y&&I<d&&(d=I),y&&I>A&&(A=I)}i[0]=r,i[1]=o,i[2]=l,i[3]=c,i[4]=f,i[5]=a,y&&(s[0]=u,s[1]=p,s[2]=d,s[3]=g,s[4]=w,s[5]=A)}function ze(n,t,e,i){let s=1/0,r=1/0,o=1/0,l=-1/0,c=-1/0,f=-1/0;for(let a=t*6,u=(t+e)*6;a<u;a+=6){const p=n[a+0];p<s&&(s=p),p>l&&(l=p);const d=n[a+2];d<r&&(r=d),d>c&&(c=d);const g=n[a+4];g<o&&(o=g),g>f&&(f=g)}i[0]=s,i[1]=r,i[2]=o,i[3]=l,i[4]=c,i[5]=f}function Fe(n,t,e,i,s){let r=e,o=e+i-1;const l=s.pos,c=s.axis*2;for(;;){for(;r<=o&&t[r*6+c]<l;)r++;for(;r<=o&&t[o*6+c]>=l;)o--;if(r<o){for(let f=0;f<3;f++){let a=n[r*3+f];n[r*3+f]=n[o*3+f],n[o*3+f]=a;let u=t[r*6+f*2+0];t[r*6+f*2+0]=t[o*6+f*2+0],t[o*6+f*2+0]=u;let p=t[r*6+f*2+1];t[r*6+f*2+1]=t[o*6+f*2+1],t[o*6+f*2+1]=p}r++,o--}else return r}}const q=32,Ee=(n,t)=>n.candidate-t.candidate,k=new Array(q).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),pt=new Float32Array(6);function Le(n,t,e,i,s,r){let o=-1,l=0;if(r===re)o=kt(t),o!==-1&&(l=(t[o]+t[o+3])/2);else if(r===ve)o=kt(n),o!==-1&&(l=Ue(e,i,s,o));else if(r===Ie){const c=et(n);let f=Mt*s;const a=i*6,u=(i+s)*6;for(let p=0;p<3;p++){const d=t[p],A=(t[p+3]-d)/q;if(s<q/4){const y=[...k];y.length=s;let m=0;for(let x=a;x<u;x+=6,m++){const b=y[m];b.candidate=e[x+2*p],b.count=0;const{bounds:P,leftCacheBounds:M,rightCacheBounds:B}=b;for(let T=0;T<3;T++)B[T]=1/0,B[T+3]=-1/0,M[T]=1/0,M[T+3]=-1/0,P[T]=1/0,P[T+3]=-1/0;ut(x,e,P)}y.sort(Ee);let h=s;for(let x=0;x<h;x++){const b=y[x];for(;x+1<h&&y[x+1].candidate===b.candidate;)y.splice(x+1,1),h--}for(let x=a;x<u;x+=6){const b=e[x+2*p];for(let P=0;P<h;P++){const M=y[P];b>=M.candidate?ut(x,e,M.rightCacheBounds):(ut(x,e,M.leftCacheBounds),M.count++)}}for(let x=0;x<h;x++){const b=y[x],P=b.count,M=s-b.count,B=b.leftCacheBounds,T=b.rightCacheBounds;let S=0;P!==0&&(S=et(B)/c);let v=0;M!==0&&(v=et(T)/c);const I=jt+Mt*(S*P+v*M);I<f&&(o=p,f=I,l=b.candidate)}}else{for(let h=0;h<q;h++){const x=k[h];x.count=0,x.candidate=d+A+h*A;const b=x.bounds;for(let P=0;P<3;P++)b[P]=1/0,b[P+3]=-1/0}for(let h=a;h<u;h+=6){let P=~~((e[h+2*p]-d)/A);P>=q&&(P=q-1);const M=k[P];M.count++,ut(h,e,M.bounds)}const y=k[q-1];Xt(y.bounds,y.rightCacheBounds);for(let h=q-2;h>=0;h--){const x=k[h],b=k[h+1];Wt(x.bounds,b.rightCacheBounds,x.rightCacheBounds)}let m=0;for(let h=0;h<q-1;h++){const x=k[h],b=x.count,P=x.bounds,B=k[h+1].rightCacheBounds;b!==0&&(m===0?Xt(P,pt):Wt(P,pt,pt)),m+=b;let T=0,S=0;m!==0&&(T=et(pt)/c);const v=s-m;v!==0&&(S=et(B)/c);const I=jt+Mt*(T*m+S*v);I<f&&(o=p,f=I,l=x.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${r} used.`);return{axis:o,pos:l}}function Ue(n,t,e,i){let s=0;for(let r=t,o=t+e;r<o;r++)s+=n[r*6+i*2];return s/e}function De(n,t){const e=n.attributes.position,i=e.array,s=n.index.array,r=s.length/3,o=new Float32Array(r*6),l=e.offset||0;let c=3;e.isInterleavedBufferAttribute&&(c=e.data.stride);for(let f=0;f<r;f++){const a=f*3,u=f*6,p=s[a+0]*c+l,d=s[a+1]*c+l,g=s[a+2]*c+l;for(let w=0;w<3;w++){const A=i[p+w],y=i[d+w],m=i[g+w];let h=A;y<h&&(h=y),m<h&&(h=m);let x=A;y>x&&(x=y),m>x&&(x=m);const b=(x-h)/2,P=w*2;o[u+P+0]=h+b,o[u+P+1]=b+(Math.abs(h)+b)*_e,h<t[w]&&(t[w]=h),x>t[w+3]&&(t[w+3]=x)}}return o}function Re(n,t){function e(y){p&&p(y/d)}function i(y,m,h,x=null,b=0){if(!g&&b>=c&&(g=!0,f&&(console.warn(`MeshBVH: Max depth of ${c} reached when generating BVH. Consider increasing maxDepth.`),console.warn(n))),h<=a||b>=c)return e(m),y.offset=m,y.count=h,y;const P=Le(y.boundingData,x,o,m,h,u);if(P.axis===-1)return e(m),y.offset=m,y.count=h,y;const M=Fe(l,o,m,h,P);if(M===m||M===m+h)e(m),y.offset=m,y.count=h;else{y.splitAxis=P.axis;const B=new ft,T=m,S=M-m;y.left=B,B.boundingData=new Float32Array(6),St(o,T,S,B.boundingData,r),i(B,T,S,r,b+1);const v=new ft,I=M,C=h-S;y.right=v,v.boundingData=new Float32Array(6),St(o,I,C,v.boundingData,r),i(v,I,C,r,b+1)}return y}Ce(n,t);const s=new Float32Array(6),r=new Float32Array(6),o=De(n,s),l=n.index.array,c=t.maxDepth,f=t.verbose,a=t.maxLeafTris,u=t.strategy,p=t.onProgress,d=n.index.count/3;let g=!1;const w=[],A=Ve(n);if(A.length===1){const y=A[0],m=new ft;m.boundingData=s,ze(o,y.offset,y.count,r),i(m,y.offset,y.count,r),w.push(m)}else for(let y of A){const m=new ft;m.boundingData=new Float32Array(6),St(o,y.offset,y.count,m.boundingData,r),i(m,y.offset,y.count,r),w.push(m)}return w}function Oe(n,t){const e=Re(n,t);let i,s,r;const o=[],l=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<e.length;a++){const u=e[a];let p=c(u);const d=new l(wt*p);i=new Float32Array(d),s=new Uint32Array(d),r=new Uint16Array(d),f(0,u),o.push(d)}return o;function c(a){return a.count?1:1+c(a.left)+c(a.right)}function f(a,u){const p=a/4,d=a/2,g=!!u.count,w=u.boundingData;for(let A=0;A<6;A++)i[p+A]=w[A];if(g){const A=u.offset,y=u.count;return s[p+6]=A,r[d+14]=y,r[d+15]=Vt,a+wt}else{const A=u.left,y=u.right,m=u.splitAxis;let h;if(h=f(a+wt,A),h/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return s[p+6]=h/4,h=f(h,y),s[p+7]=m,h}}}class H{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let i=1/0,s=-1/0;for(let r=0,o=t.length;r<o;r++){const c=t[r][e];i=c<i?c:i,s=c>s?c:s}this.min=i,this.max=s}setFromPoints(t,e){let i=1/0,s=-1/0;for(let r=0,o=e.length;r<o;r++){const l=e[r],c=t.dot(l);i=c<i?c:i,s=c>s?c:s}this.min=i,this.max=s}isSeparated(t){return this.min>t.max||t.min>this.max}}H.prototype.setFromBox=function(){const n=new _;return function(e,i){const s=i.min,r=i.max;let o=1/0,l=-1/0;for(let c=0;c<=1;c++)for(let f=0;f<=1;f++)for(let a=0;a<=1;a++){n.x=s.x*c+r.x*(1-c),n.y=s.y*f+r.y*(1-f),n.z=s.z*a+r.z*(1-a);const u=e.dot(n);o=Math.min(u,o),l=Math.max(u,l)}this.min=o,this.max=l}}();const qe=function(){const n=new _,t=new _,e=new _;return function(s,r,o){const l=s.start,c=n,f=r.start,a=t;e.subVectors(l,f),n.subVectors(s.end,r.start),t.subVectors(r.end,r.start);const u=e.dot(a),p=a.dot(c),d=a.dot(a),g=e.dot(c),A=c.dot(c)*d-p*p;let y,m;A!==0?y=(u*p-g*d)/A:y=0,m=(u+y*p)/d,o.x=y,o.y=m}}(),Lt=function(){const n=new at,t=new _,e=new _;return function(s,r,o,l){qe(s,r,n);let c=n.x,f=n.y;if(c>=0&&c<=1&&f>=0&&f<=1){s.at(c,o),r.at(f,l);return}else if(c>=0&&c<=1){f<0?r.at(0,l):r.at(1,l),s.closestPointToPoint(l,!0,o);return}else if(f>=0&&f<=1){c<0?s.at(0,o):s.at(1,o),r.closestPointToPoint(o,!0,l);return}else{let a;c<0?a=s.start:a=s.end;let u;f<0?u=r.start:u=r.end;const p=t,d=e;if(s.closestPointToPoint(u,!0,t),r.closestPointToPoint(a,!0,e),p.distanceToSquared(u)<=d.distanceToSquared(a)){o.copy(p),l.copy(u);return}else{o.copy(a),l.copy(d);return}}}}(),Ne=function(){const n=new _,t=new _,e=new oe,i=new N;return function(r,o){const{radius:l,center:c}=r,{a:f,b:a,c:u}=o;if(i.start=f,i.end=a,i.closestPointToPoint(c,!0,n).distanceTo(c)<=l||(i.start=f,i.end=u,i.closestPointToPoint(c,!0,n).distanceTo(c)<=l)||(i.start=a,i.end=u,i.closestPointToPoint(c,!0,n).distanceTo(c)<=l))return!0;const w=o.getPlane(e);if(Math.abs(w.distanceToPoint(c))<=l){const y=w.projectPoint(c,t);if(o.containsPoint(y))return!0}return!1}}();class j extends Ct{constructor(...t){super(...t),this.isSeparatingAxisTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new _),this.satBounds=new Array(4).fill().map(()=>new H),this.points=[this.a,this.b,this.c],this.sphere=new me,this.plane=new oe,this.needsUpdate=!1}intersectsSphere(t){return Ne(t,this)}update(){const t=this.a,e=this.b,i=this.c,s=this.points,r=this.satAxes,o=this.satBounds,l=r[0],c=o[0];this.getNormal(l),c.setFromPoints(l,s);const f=r[1],a=o[1];f.subVectors(t,e),a.setFromPoints(f,s);const u=r[2],p=o[2];u.subVectors(e,i),p.setFromPoints(u,s);const d=r[3],g=o[3];d.subVectors(i,t),g.setFromPoints(d,s),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}j.prototype.closestPointToSegment=function(){const n=new _,t=new _,e=new N;return function(s,r=null,o=null){const{start:l,end:c}=s,f=this.points;let a,u=1/0;for(let p=0;p<3;p++){const d=(p+1)%3;e.start.copy(f[p]),e.end.copy(f[d]),Lt(e,s,n,t),a=n.distanceToSquared(t),a<u&&(u=a,r&&r.copy(n),o&&o.copy(t))}return this.closestPointToPoint(l,n),a=l.distanceToSquared(n),a<u&&(u=a,r&&r.copy(n),o&&o.copy(l)),this.closestPointToPoint(c,n),a=c.distanceToSquared(n),a<u&&(u=a,r&&r.copy(n),o&&o.copy(c)),Math.sqrt(u)}}();j.prototype.intersectsTriangle=function(){const n=new j,t=new Array(3),e=new Array(3),i=new H,s=new H,r=new _,o=new _,l=new _,c=new _,f=new N,a=new N,u=new N;return function(d,g=null){this.needsUpdate&&this.update(),d.isSeparatingAxisTriangle?d.needsUpdate&&d.update():(n.copy(d),n.update(),d=n);const w=this.satBounds,A=this.satAxes;e[0]=d.a,e[1]=d.b,e[2]=d.c;for(let h=0;h<4;h++){const x=w[h],b=A[h];if(i.setFromPoints(b,e),x.isSeparated(i))return!1}const y=d.satBounds,m=d.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let h=0;h<4;h++){const x=y[h],b=m[h];if(i.setFromPoints(b,t),x.isSeparated(i))return!1}for(let h=0;h<4;h++){const x=A[h];for(let b=0;b<4;b++){const P=m[b];if(r.crossVectors(x,P),i.setFromPoints(r,t),s.setFromPoints(r,e),i.isSeparated(s))return!1}}if(g){const h=this.plane,x=d.plane;if(Math.abs(h.normal.dot(x.normal))>1-1e-10)console.warn("SeparatingAxisTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),g.start.set(0,0,0),g.end.set(0,0,0);else{const b=this.points;let P=!1;for(let T=0;T<3;T++){const S=b[T],v=b[(T+1)%3];if(f.start.copy(S),f.end.copy(v),x.intersectLine(f,P?a.start:a.end)){if(P)break;P=!0}}const M=d.points;let B=!1;for(let T=0;T<3;T++){const S=M[T],v=M[(T+1)%3];if(f.start.copy(S),f.end.copy(v),h.intersectLine(f,B?u.start:u.end)){if(B)break;B=!0}}if(a.delta(o),u.delta(l),o.dot(l)<0){let T=u.start;u.start=u.end,u.end=T}c.subVectors(a.start,u.start),c.dot(o)>0?g.start.copy(a.start):g.start.copy(u.start),c.subVectors(a.end,u.end),c.dot(o)<0?g.end.copy(a.end):g.end.copy(u.end)}}return!0}}();j.prototype.distanceToPoint=function(){const n=new _;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();j.prototype.distanceToTriangle=function(){const n=new _,t=new _,e=["a","b","c"],i=new N,s=new N;return function(o,l=null,c=null){const f=l||c?i:null;if(this.intersectsTriangle(o,f))return(l||c)&&(l&&f.getCenter(l),c&&f.getCenter(c)),0;let a=1/0;for(let u=0;u<3;u++){let p;const d=e[u],g=o[d];this.closestPointToPoint(g,n),p=g.distanceToSquared(n),p<a&&(a=p,l&&l.copy(n),c&&c.copy(g));const w=this[d];o.closestPointToPoint(w,n),p=w.distanceToSquared(n),p<a&&(a=p,l&&l.copy(w),c&&c.copy(n))}for(let u=0;u<3;u++){const p=e[u],d=e[(u+1)%3];i.set(this[p],this[d]);for(let g=0;g<3;g++){const w=e[g],A=e[(g+1)%3];s.set(o[w],o[A]),Lt(i,s,n,t);const y=n.distanceToSquared(t);y<a&&(a=y,l&&l.copy(n),c&&c.copy(t))}}return Math.sqrt(a)}}();class O extends ${constructor(...t){super(...t),this.isOrientedBox=!0,this.matrix=new gt,this.invMatrix=new gt,this.points=new Array(8).fill().map(()=>new _),this.satAxes=new Array(3).fill().map(()=>new _),this.satBounds=new Array(3).fill().map(()=>new H),this.alignedSatBounds=new Array(3).fill().map(()=>new H),this.needsUpdate=!1}set(t,e,i){super.set(t,e),this.matrix=i,this.needsUpdate=!0}copy(t){super.copy(t),this.matrix.copy(t.matrix),this.needsUpdate=!0}}O.prototype.update=function(){return function(){const t=this.matrix,e=this.min,i=this.max,s=this.points;for(let f=0;f<=1;f++)for(let a=0;a<=1;a++)for(let u=0;u<=1;u++){const p=1*f|2*a|4*u,d=s[p];d.x=f?i.x:e.x,d.y=a?i.y:e.y,d.z=u?i.z:e.z,d.applyMatrix4(t)}const r=this.satBounds,o=this.satAxes,l=s[0];for(let f=0;f<3;f++){const a=o[f],u=r[f],p=1<<f,d=s[p];a.subVectors(l,d),u.setFromPoints(a,s)}const c=this.alignedSatBounds;c[0].setFromPointsField(s,"x"),c[1].setFromPointsField(s,"y"),c[2].setFromPointsField(s,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();O.prototype.intersectsBox=function(){const n=new H;return function(e){this.needsUpdate&&this.update();const i=e.min,s=e.max,r=this.satBounds,o=this.satAxes,l=this.alignedSatBounds;if(n.min=i.x,n.max=s.x,l[0].isSeparated(n)||(n.min=i.y,n.max=s.y,l[1].isSeparated(n))||(n.min=i.z,n.max=s.z,l[2].isSeparated(n)))return!1;for(let c=0;c<3;c++){const f=o[c],a=r[c];if(n.setFromBox(f,e),a.isSeparated(n))return!1}return!0}}();O.prototype.intersectsTriangle=function(){const n=new j,t=new Array(3),e=new H,i=new H,s=new _;return function(o){this.needsUpdate&&this.update(),o.isSeparatingAxisTriangle?o.needsUpdate&&o.update():(n.copy(o),n.update(),o=n);const l=this.satBounds,c=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let p=0;p<3;p++){const d=l[p],g=c[p];if(e.setFromPoints(g,t),d.isSeparated(e))return!1}const f=o.satBounds,a=o.satAxes,u=this.points;for(let p=0;p<3;p++){const d=f[p],g=a[p];if(e.setFromPoints(g,u),d.isSeparated(e))return!1}for(let p=0;p<3;p++){const d=c[p];for(let g=0;g<4;g++){const w=a[g];if(s.crossVectors(d,w),e.setFromPoints(s,t),i.setFromPoints(s,u),e.isSeparated(i))return!1}}return!0}}();O.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();O.prototype.distanceToPoint=function(){const n=new _;return function(e){return this.closestPointToPoint(e,n),e.distanceTo(n)}}();O.prototype.distanceToBox=function(){const n=["x","y","z"],t=new Array(12).fill().map(()=>new N),e=new Array(12).fill().map(()=>new N),i=new _,s=new _;return function(o,l=0,c=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(c||f)&&(o.getCenter(s),this.closestPointToPoint(s,i),o.closestPointToPoint(i,s),c&&c.copy(i),f&&f.copy(s)),0;const a=l*l,u=o.min,p=o.max,d=this.points;let g=1/0;for(let A=0;A<8;A++){const y=d[A];s.copy(y).clamp(u,p);const m=y.distanceToSquared(s);if(m<g&&(g=m,c&&c.copy(y),f&&f.copy(s),m<a))return Math.sqrt(m)}let w=0;for(let A=0;A<3;A++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){const h=(A+1)%3,x=(A+2)%3,b=y<<h|m<<x,P=1<<A|y<<h|m<<x,M=d[b],B=d[P];t[w].set(M,B);const S=n[A],v=n[h],I=n[x],C=e[w],F=C.start,V=C.end;F[S]=u[S],F[v]=y?u[v]:p[v],F[I]=m?u[I]:p[v],V[S]=p[S],V[v]=y?u[v]:p[v],V[I]=m?u[I]:p[v],w++}for(let A=0;A<=1;A++)for(let y=0;y<=1;y++)for(let m=0;m<=1;m++){s.x=A?p.x:u.x,s.y=y?p.y:u.y,s.z=m?p.z:u.z,this.closestPointToPoint(s,i);const h=s.distanceToSquared(i);if(h<g&&(g=h,c&&c.copy(i),f&&f.copy(s),h<a))return Math.sqrt(h)}for(let A=0;A<12;A++){const y=t[A];for(let m=0;m<12;m++){const h=e[m];Lt(y,h,i,s);const x=i.distanceToSquared(s);if(x<g&&(g=x,c&&c.copy(i),f&&f.copy(s),x<a))return Math.sqrt(x)}}return Math.sqrt(g)}}();const dt=new _,ht=new _,yt=new _,Gt=new at,$t=new at,Yt=new at,Zt=new _;function He(n,t,e,i,s,r){let o;return r===Ae?o=n.intersectTriangle(i,e,t,!0,s):o=n.intersectTriangle(t,e,i,r!==ge,s),o===null?null:{distance:n.origin.distanceTo(s),point:s.clone()}}function je(n,t,e,i,s,r,o){dt.fromBufferAttribute(t,i),ht.fromBufferAttribute(t,s),yt.fromBufferAttribute(t,r);const l=He(n,dt,ht,yt,Zt,o);if(l){e&&(Gt.fromBufferAttribute(e,i),$t.fromBufferAttribute(e,s),Yt.fromBufferAttribute(e,r),l.uv=Ct.getUV(Zt,dt,ht,yt,Gt,$t,Yt,new at));const c={a:i,b:s,c:r,normal:new _,materialIndex:0};Ct.getNormal(dt,ht,yt,c.normal),l.face=c,l.faceIndex=i}return l}function ce(n,t,e,i,s){const r=i*3,o=n.index.getX(r),l=n.index.getX(r+1),c=n.index.getX(r+2),f=je(e,n.attributes.position,n.attributes.uv,o,l,c,t);return f?(f.faceIndex=i,s&&s.push(f),f):null}function ke(n,t,e,i,s,r){for(let o=i,l=i+s;o<l;o++)ce(n,t,e,o,r)}function Xe(n,t,e,i,s){let r=1/0,o=null;for(let l=i,c=i+s;l<c;l++){const f=ce(n,t,e,l);f&&f.distance<r&&(o=f,r=f.distance)}return o}function ae(n,t,e){return n===null||(n.point.applyMatrix4(t.matrixWorld),n.distance=n.point.distanceTo(e.ray.origin),n.object=t,n.distance<e.near||n.distance>e.far)?null:n}function R(n,t,e,i){const s=n.a,r=n.b,o=n.c;let l=t,c=t+1,f=t+2;e&&(l=e.getX(t),c=e.getX(t+1),f=e.getX(t+2)),s.x=i.getX(l),s.y=i.getY(l),s.z=i.getZ(l),r.x=i.getX(c),r.y=i.getY(c),r.z=i.getZ(c),o.x=i.getX(f),o.y=i.getY(f),o.z=i.getZ(f)}function Kt(n,t,e,i,s,r,o){const l=e.index,c=e.attributes.position;for(let f=n,a=t+n;f<a;f++)if(R(o,f*3,l,c),o.needsUpdate=!0,i(o,f,s,r))return!0;return!1}class le{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function X(n,t){return t[n+15]===65535}function Q(n,t){return t[n+6]}function ot(n,t){return t[n+14]}function rt(n){return n+8}function ct(n,t){return t[n+6]}function We(n,t){return t[n+7]}const J=new $,Pt=new _,Ge=["x","y","z"];function zt(n,t,e,i,s){let r=n*2,o=tt,l=W,c=G;if(X(r,l)){const a=Q(n,c),u=ot(r,l);ke(t,e,i,a,u,s)}else{const a=rt(n);Tt(a,o,i,Pt)&&zt(a,t,e,i,s);const u=ct(n,c);Tt(u,o,i,Pt)&&zt(u,t,e,i,s)}}function Ft(n,t,e,i){let s=n*2,r=tt,o=W,l=G;if(X(s,o)){const f=Q(n,l),a=ot(s,o);return Xe(t,e,i,f,a)}else{const f=We(n,l),a=Ge[f],p=i.direction[a]>=0;let d,g;p?(d=rt(n),g=ct(n,l)):(d=ct(n,l),g=rt(n));const A=Tt(d,r,i,Pt)?Ft(d,t,e,i):null;if(A){const h=A.point[a];if(p?h<=r[g+f]:h>=r[g+f+3])return A}const m=Tt(g,r,i,Pt)?Ft(g,t,e,i):null;return A&&m?A.distance<=m.distance?A:m:A||m||null}}const $e=function(){let n,t;const e=[],i=new le(()=>new $);return function(...o){n=i.getPrimitive(),t=i.getPrimitive(),e.push(n,t);const l=s(...o);i.releasePrimitive(n),i.releasePrimitive(t),e.pop(),e.pop();const c=e.length;return c>0&&(t=e[c-1],n=e[c-2]),l};function s(r,o,l,c,f=null,a=0,u=0){function p(h){let x=h*2,b=W,P=G;for(;!X(x,b);)h=rt(h),x=h*2;return Q(h,P)}function d(h){let x=h*2,b=W,P=G;for(;!X(x,b);)h=ct(h,P),x=h*2;return Q(h,P)+ot(x,b)}let g=r*2,w=tt,A=W,y=G;if(X(g,A)){const h=Q(r,y),x=ot(g,A);return U(r,w,n),c(h,x,!1,u,a+r,n)}else{const h=rt(r),x=ct(r,y);let b=h,P=x,M,B,T,S;if(f&&(T=n,S=t,U(b,w,T),U(P,w,S),M=f(T),B=f(S),B<M)){b=x,P=h;const L=M;M=B,B=L,T=S}T||(T=n,U(b,w,T));const v=X(b*2,A),I=l(T,v,M,u+1,a+b);let C;if(I===Ht){const L=p(b),Z=d(b)-L;C=c(L,Z,!0,u+1,a+b,T)}else C=I&&s(b,o,l,c,f,a,u+1);if(C)return!0;S=t,U(P,w,S);const F=X(P*2,A),V=l(S,F,B,u+1,a+P);let E;if(V===Ht){const L=p(P),Z=d(P)-L;E=c(L,Z,!0,u+1,a+P,S)}else E=V&&s(P,o,l,c,f,a,u+1);return!!E}}}(),Ye=function(){const n=new j,t=new j,e=new gt,i=new O,s=new O;return function r(o,l,c,f,a=null){let u=o*2,p=tt,d=W,g=G;if(a===null&&(c.boundingBox||c.computeBoundingBox(),i.set(c.boundingBox.min,c.boundingBox.max,f),a=i),X(u,d)){const A=l,y=A.index,m=A.attributes.position,h=c.index,x=c.attributes.position,b=Q(o,g),P=ot(u,d);if(e.copy(f).invert(),c.boundsTree)return U(o,p,s),s.matrix.copy(e),s.needsUpdate=!0,c.boundsTree.shapecast({intersectsBounds:B=>s.intersectsBox(B),intersectsTriangle:B=>{B.a.applyMatrix4(f),B.b.applyMatrix4(f),B.c.applyMatrix4(f),B.needsUpdate=!0;for(let T=b*3,S=(P+b)*3;T<S;T+=3)if(R(t,T,y,m),t.needsUpdate=!0,B.intersectsTriangle(t))return!0;return!1}});for(let M=b*3,B=P+b*3;M<B;M+=3){R(n,M,y,m),n.a.applyMatrix4(e),n.b.applyMatrix4(e),n.c.applyMatrix4(e),n.needsUpdate=!0;for(let T=0,S=h.count;T<S;T+=3)if(R(t,T,h,x),t.needsUpdate=!0,n.intersectsTriangle(t))return!0}}else{const A=o+8,y=g[o+6];return U(A,p,J),!!(a.intersectsBox(J)&&r(A,l,c,f,a)||(U(y,p,J),a.intersectsBox(J)&&r(y,l,c,f,a)))}}}();function Tt(n,t,e,i){return U(n,t,J),e.intersectBox(J,i)}const Et=[];let At,tt,W,G;function it(n){At&&Et.push(At),At=n,tt=new Float32Array(n),W=new Uint16Array(n),G=new Uint32Array(n)}function mt(){At=null,tt=null,W=null,G=null,Et.length&&it(Et.pop())}const vt=Symbol("skip tree generation"),It=new $,_t=new $,K=new gt,Y=new O,nt=new O,st=new _,xt=new _,Ze=new _,Ke=new _,Je=new _,Jt=new $,D=new le(()=>new j);class z{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),z.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e=Bt({cloneBuffers:!0},e);const i=t.geometry,s=t._roots,r=i.getIndex();let o;return e.cloneBuffers?o={roots:s.map(l=>l.slice()),index:r.array.slice()}:o={roots:s,index:r.array},o}static deserialize(t,e,i={}){if(typeof i=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),z.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});i=Bt({setIndex:!0},i);const{index:s,roots:r}=t,o=new z(e,Se(Bt({},i),{[vt]:!0}));if(o._roots=r,i.setIndex){const l=e.getIndex();if(l===null){const c=new bt(t.index,1,!1);e.setIndex(c)}else l.array!==s&&(l.array.set(s),l.needsUpdate=!0)}return o}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:re,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[vt]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer>"u")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[vt]||(this._roots=Oe(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new $))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,i=e.index.array,s=e.attributes.position,r=s.array,o=s.offset||0;let l=3;s.isInterleavedBufferAttribute&&(l=s.data.stride);let c,f,a,u,p=0;const d=this._roots;for(let w=0,A=d.length;w<A;w++)c=d[w],f=new Uint32Array(c),a=new Uint16Array(c),u=new Float32Array(c),g(0,p),p+=c.byteLength;function g(w,A,y=!1){const m=w*2;if(a[m+15]===Vt){const x=f[w+6],b=a[m+14];let P=1/0,M=1/0,B=1/0,T=-1/0,S=-1/0,v=-1/0;for(let I=3*x,C=3*(x+b);I<C;I++){const F=i[I]*l+o,V=r[F+0],E=r[F+1],L=r[F+2];V<P&&(P=V),V>T&&(T=V),E<M&&(M=E),E>S&&(S=E),L<B&&(B=L),L>v&&(v=L)}return u[w+0]!==P||u[w+1]!==M||u[w+2]!==B||u[w+3]!==T||u[w+4]!==S||u[w+5]!==v?(u[w+0]=P,u[w+1]=M,u[w+2]=B,u[w+3]=T,u[w+4]=S,u[w+5]=v,!0):!1}else{const x=w+8,b=f[w+6],P=x+A,M=b+A;let B=y,T=!1,S=!1;t?B||(T=t.has(P),S=t.has(M),B=!T&&!S):(T=!0,S=!0);const v=B||T,I=B||S;let C=!1;v&&(C=g(x,A,B));let F=!1;I&&(F=g(b,A,B));const V=C||F;if(V)for(let E=0;E<3;E++){const L=x+E,lt=b+E,Z=u[L],Ut=u[L+3],Dt=u[lt],Rt=u[lt+3];u[w+E]=Z<Dt?Z:Dt,u[w+E+3]=Ut>Rt?Ut:Rt}return V}}}traverse(t,e=0){const i=this._roots[e],s=new Uint32Array(i),r=new Uint16Array(i);o(0);function o(l,c=0){const f=l*2,a=r[f+15]===Vt;if(a){const u=s[l+6],p=r[f+14];t(c,a,new Float32Array(i,l*4,6),u,p)}else{const u=l+wt/4,p=s[l+6],d=s[l+7];t(c,a,new Float32Array(i,l*4,6),d)||(o(u,c+1),o(p,c+1))}}}raycast(t,e=Ot){const i=this._roots,s=this.geometry,r=[],o=e.isMaterial,l=Array.isArray(e),c=s.groups,f=o?e.side:e;for(let a=0,u=i.length;a<u;a++){const p=l?e[c[a].materialIndex].side:f,d=r.length;if(it(i[a]),zt(0,s,p,t,r),mt(),l){const g=c[a].materialIndex;for(let w=d,A=r.length;w<A;w++)r[w].face.materialIndex=g}}return r}raycastFirst(t,e=Ot){const i=this._roots,s=this.geometry,r=e.isMaterial,o=Array.isArray(e);let l=null;const c=s.groups,f=r?e.side:e;for(let a=0,u=i.length;a<u;a++){const p=o?e[c[a].materialIndex].side:f;it(i[a]);const d=Ft(0,s,p,t);mt(),d!=null&&(l==null||d.distance<l.distance)&&(l=d,o&&(d.face.materialIndex=c[a].materialIndex))}return l}intersectsGeometry(t,e){const i=this.geometry;let s=!1;for(const r of this._roots)if(it(r),s=Ye(0,i,t,e),mt(),s)break;return s}shapecast(t,e,i){const s=this.geometry;if(t instanceof Function){if(e){const p=e;e=(d,g,w,A)=>{const y=g*3;return p(d,y,y+1,y+2,w,A)}}t={boundsTraverseOrder:i,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const r=D.getPrimitive();let{boundsTraverseOrder:o,intersectsBounds:l,intersectsRange:c,intersectsTriangle:f}=t;if(c&&f){const p=c;c=(d,g,w,A,y)=>p(d,g,w,A,y)?!0:Kt(d,g,s,f,w,A,r)}else c||(f?c=(p,d,g,w)=>Kt(p,d,s,f,g,w,r):c=(p,d,g)=>g);let a=!1,u=0;for(const p of this._roots){if(it(p),a=$e(0,s,l,c,o,u),mt(),a)break;u+=p.byteLength}return D.releasePrimitive(r),a}bvhcast(t,e,i){let{intersectsRanges:s,intersectsTriangles:r}=i;const o=this.geometry.index,l=this.geometry.attributes.position,c=t.geometry.index,f=t.geometry.attributes.position;K.copy(e).invert();const a=D.getPrimitive(),u=D.getPrimitive();if(r){let d=function(g,w,A,y,m,h,x,b){for(let P=A,M=A+y;P<M;P++){R(u,P*3,c,f),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let B=g,T=g+w;B<T;B++)if(R(a,B*3,o,l),a.needsUpdate=!0,r(a,u,B,P,m,h,x,b))return!0}return!1};if(s){const g=s;s=function(w,A,y,m,h,x,b,P){return g(w,A,y,m,h,x,b,P)?!0:d(w,A,y,m,h,x,b,P)}}else s=d}this.getBoundingBox(_t),_t.applyMatrix4(e);const p=this.shapecast({intersectsBounds:d=>_t.intersectsBox(d),intersectsRange:(d,g,w,A,y,m)=>(It.copy(m),It.applyMatrix4(K),t.shapecast({intersectsBounds:h=>It.intersectsBox(h),intersectsRange:(h,x,b,P,M)=>s(d,g,h,x,A,y,P,M)}))});return D.releasePrimitive(a),D.releasePrimitive(u),p}intersectsBox(t,e){return Y.set(t.min,t.max,e),Y.needsUpdate=!0,this.shapecast({intersectsBounds:i=>Y.intersectsBox(i),intersectsTriangle:i=>Y.intersectsTriangle(i)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,i={},s={},r=0,o=1/0){t.boundingBox||t.computeBoundingBox(),Y.set(t.boundingBox.min,t.boundingBox.max,e),Y.needsUpdate=!0;const l=this.geometry,c=l.attributes.position,f=l.index,a=t.attributes.position,u=t.index,p=D.getPrimitive(),d=D.getPrimitive();let g=xt,w=Ze,A=null,y=null;s&&(A=Ke,y=Je);let m=1/0,h=null,x=null;return K.copy(e).invert(),nt.matrix.copy(K),this.shapecast({boundsTraverseOrder:b=>Y.distanceToBox(b,Math.min(m,o)),intersectsBounds:(b,P,M)=>M<m&&M<o?(P&&(nt.min.copy(b.min),nt.max.copy(b.max),nt.needsUpdate=!0),!0):!1,intersectsRange:(b,P)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:M=>nt.distanceToBox(M,Math.min(m,o)),intersectsBounds:(M,B,T)=>T<m&&T<o,intersectsRange:(M,B)=>{for(let T=M*3,S=(M+B)*3;T<S;T+=3){R(d,T,u,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let v=b*3,I=(b+P)*3;v<I;v+=3){R(p,v,f,c),p.needsUpdate=!0;const C=p.distanceToTriangle(d,g,A);if(C<m&&(w.copy(g),y&&y.copy(A),m=C,h=v/3,x=T/3),C<r)return!0}}}});{const M=u?u.count:a.count;for(let B=0,T=M;B<T;B+=3){R(d,B,u,a),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let S=b*3,v=(b+P)*3;S<v;S+=3){R(p,S,f,c),p.needsUpdate=!0;const I=p.distanceToTriangle(d,g,A);if(I<m&&(w.copy(g),y&&y.copy(A),m=I,h=S/3,x=B/3),I<r)return!0}}}}}),D.releasePrimitive(p),D.releasePrimitive(d),m===1/0?null:(i.point?i.point.copy(w):i.point=w.clone(),i.distance=m,i.faceIndex=h,s&&(s.point?s.point.copy(y):s.point=y.clone(),s.point.applyMatrix4(K),w.applyMatrix4(K),s.distance=w.sub(s.point).length(),s.faceIndex=x),i)}closestPointToPoint(t,e={},i=0,s=1/0){const r=i*i,o=s*s;let l=1/0,c=null;if(this.shapecast({boundsTraverseOrder:a=>(st.copy(t).clamp(a.min,a.max),st.distanceToSquared(t)),intersectsBounds:(a,u,p)=>p<l&&p<o,intersectsTriangle:(a,u)=>{a.closestPointToPoint(t,st);const p=t.distanceToSquared(st);return p<l&&(xt.copy(st),l=p,c=u),p<r}}),l===1/0)return null;const f=Math.sqrt(l);return e.point?e.point.copy(xt):e.point=xt.clone(),e.distance=f,e.faceIndex=c,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(i=>{U(0,new Float32Array(i),Jt),t.union(Jt)}),t}}const Qt=z.prototype.raycast;z.prototype.raycast=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycast" has changed. See docs for new signature.');const[t,e,i,s]=n;return Qt.call(this,i,t.material).forEach(o=>{o=ae(o,t,e),o&&s.push(o)}),s}else return Qt.apply(this,n)};const te=z.prototype.raycastFirst;z.prototype.raycastFirst=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "raycastFirst" has changed. See docs for new signature.');const[t,e,i]=n;return ae(te.call(this,i,t.material),t,e)}else return te.apply(this,n)};const ee=z.prototype.closestPointToPoint;z.prototype.closestPointToPoint=function(...n){if(n[0].isMesh){console.warn('MeshBVH: The function signature and results frame for "closestPointToPoint" has changed. See docs for new signature.'),n.unshift();const t=n[1],e={};return n[1]=e,ee.apply(this,n),t&&t.copy(e.point),e.distance}else return ee.apply(this,n)};const ne=z.prototype.closestPointToGeometry;z.prototype.closestPointToGeometry=function(...n){const t=n[2],e=n[3];if(t&&t.isVector3||e&&e.isVector3){console.warn('MeshBVH: The function signature and results frame for "closestPointToGeometry" has changed. See docs for new signature.');const i={},s={},r=n[1];return n[2]=i,n[3]=s,ne.apply(this,n),t&&t.copy(i.point),e&&e.copy(s.point).applyMatrix4(r),i.distance}else return ne.apply(this,n)};const se=z.prototype.refit;z.prototype.refit=function(...n){const t=n[0],e=n[1];if(e&&(e instanceof Set||Array.isArray(e))){console.warn('MeshBVH: The function signature for "refit" has changed. See docs for new signature.');const i=new Set;e.forEach(s=>i.add(s)),t&&t.forEach(s=>i.add(s)),se.call(this,i)}else se.apply(this,n)};["intersectsGeometry","shapecast","intersectsBox","intersectsSphere"].forEach(n=>{const t=z.prototype[n];z.prototype[n]=function(...e){return(e[0]===null||e[0].isMesh)&&(e.shift(),console.warn(`MeshBVH: The function signature for "${n}" has changed and no longer takes Mesh. See docs for new signature.`)),t.apply(this,e)}});const ie=new $;class Qe extends xe{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,i=10,s=0){super(),this.material=e,this.geometry=new we,this.name="MeshBVHRootVisualizer",this.depth=i,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=s}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,i=this._group;if(t.dispose(),this.visible=!1,e){const s=this.depth-1,r=this.displayParents;let o=0;e.traverse((p,d)=>{if(p===s||d)return o++,!0;r&&o++},i);let l=0;const c=new Float32Array(8*3*o);e.traverse((p,d,g)=>{const w=p===s||d;if(w||r){U(0,g,ie);const{min:A,max:y}=ie;for(let m=-1;m<=1;m+=2){const h=m<0?A.x:y.x;for(let x=-1;x<=1;x+=2){const b=x<0?A.y:y.y;for(let P=-1;P<=1;P+=2){const M=P<0?A.z:y.z;c[l+0]=h,c[l+1]=b,c[l+2]=M,l+=3}}}return w}},i);let f,a;this.displayEdges?a=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):a=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),c.length>65535?f=new Uint32Array(a.length*o):f=new Uint16Array(a.length*o);const u=a.length;for(let p=0;p<o;p++){const d=p*8,g=p*u;for(let w=0;w<u;w++)f[g+w]=d+a[w]}t.setIndex(new bt(f,1,!1)),t.setAttribute("position",new bt(c,3,!1)),this.visible=!0}}}class fe extends ue{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const i=new pe({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),s=new de({color:65416,transparent:!0,opacity:.3,depthWrite:!1});s.color=i.color,this.edgeMaterial=i,this.meshMaterial=s,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;)this._roots.pop();for(let i=0;i<e;i++){if(i>=this._roots.length){const r=new Qe(this.mesh,this.edgeMaterial,this.depth,i);this.add(r),this._roots.push(r)}const s=this._roots[i];s.depth=this.depth,s.mesh=this.mesh,s.displayParents=this.displayParents,s.displayEdges=this.displayEdges,s.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,s.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new fe(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,i=t.length;e<i;e++)t[e].geometry.dispose()}}he.prototype.raycast;const tn=new WeakMap;var nn=n=>{n.outerObject3d.updateMatrixWorld(!0);const t=[];n.outerObject3d.traverse(i=>{if(!i.geometry||i===n.object3d&&!(n instanceof ye))return;const s=i.geometry.clone();s.applyMatrix4(i.matrixWorld),t.push(s),s.dispose()});const e=[];for(const i of t){const s=i.boundsTree=new z(i);e.push(s),tn.set(s,n)}return[e,t]};export{fe as M,tn as b,nn as c};
